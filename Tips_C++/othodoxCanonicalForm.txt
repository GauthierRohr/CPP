ORTHODOX CANONICAL FORM CLASS

En C++, une classe en Orthodox Canonical Form (souvent abrÃ©gÃ© OCCF)
dÃ©signe une classe qui implÃ©mente les fonctions membres â€œspÃ©cialesâ€ de base
pour gÃ©rer correctement la crÃ©ation, la copie, lâ€™affectation et la destruction des objets.

Câ€™est historiquement liÃ© Ã  la Rule of Three (la rÃ¨gle des trois) et Ã  la maniÃ¨re â€œcanoniqueâ€ de dÃ©finir un type valeur.  ï¿¼

ğŸ“Œ Ce que doit contenir une classe en Orthodox Canonical Form

Une classe en forme canonique orthodoxe doit dÃ©finir explicitement au minimum :  ï¿¼
	1.	Constructeur par dÃ©faut
	2.	Constructeur de copie
	3.	OpÃ©rateur dâ€™affectation (operator=)
	4.	Destructeur

Ces membres assurent que lâ€™objet peut Ãªtre crÃ©Ã©, copiÃ©, assignÃ© et dÃ©truit de maniÃ¨re sÃ»re et prÃ©visible.

public:
    Fixed();
    Fixed(const Fixed& copy);
    ~Fixed();
    Fixed &operator=(const Fixed& copy);

1 - Pourquoi existe-t-il un constructeur de copie ?

Un constructeur de copie sert Ã  crÃ©er un nouvel objet comme copie dâ€™un objet dÃ©jÃ  existant.
ğŸ‘‰ Câ€™est utilisÃ© au moment de la crÃ©ation de lâ€™objet, pas aprÃ¨s.  ï¿¼

Exemples de situations oÃ¹ il est appelÃ© :
	â€¢	Fixed b = a; â†’ on crÃ©e b en copiant a.
	â€¢	Une fonction retourne un objet par valeur.
	â€¢	Un objet est passÃ© par valeur Ã  une fonction.
Dans chacun de ces cas, lâ€™objet cible nâ€™existait pas encore, donc il doit Ãªtre initialisÃ©.  ï¿¼

Sans constructeur de copie, le compilateur en gÃ©nÃ¨re un par dÃ©faut qui fait une copie membre Ã  membre (shallow copy),
ce qui peut Ãªtre inappropriÃ© si ta classe gÃ¨re des ressources (ex. mÃ©moire dynamique).

2 - Pourquoi existe-t-il un opÃ©rateur dâ€™affectation (operator=) ?

Lâ€™opÃ©rateur dâ€™affectation sert Ã  copier les valeurs dâ€™un objet vers un autre qui existe dÃ©jÃ .
ğŸ‘‰ On lâ€™utilise quand lâ€™objet de gauche a dÃ©jÃ  Ã©tÃ© crÃ©Ã©.  ï¿¼

Exemple concret :

Fixed a;     // crÃ©Ã© via constructeur par dÃ©faut
Fixed b;     // autre objet dÃ©jÃ  crÃ©Ã©
b = a;       // ici, on **affecte** a dans b â†’ opÃ©rateur dâ€™affectation

//////////////////////////////////////////////////////////////////////////////////////////////////
//  Mais pourquoi s'embÃªter Ã  faire :															//
//  Fixed c;                         															//
//  c = b;																						//
//																							 	//
//  Alors qu'on aurait pu faire Fixed c(b) ou Fixed c(a) et du coup Ã  quoi sert l'opÃ©rateur ??? //
//////////////////////////////////////////////////////////////////////////////////////////////////

â¡ Parce que la vie dâ€™un objet se dÃ©roule en 2 phases diffÃ©rentes :
	1.	sa CRÃ‰ATION
	2.	sa MODIFICATION plus tard.

1. Les deux situations nâ€™ont rien Ã  voir

	A. Ã€ la crÃ©ation de lâ€™objet
	Fixed c(b);

	ğŸ‘‰ lâ€™objet c Nâ€™EXISTE PAS encore
	â¡ on le construit directement Ã  partir de b
	â†’ constructeur de copie.

	B. AprÃ¨s la crÃ©ation
	Fixed c;
	c = b;

	ğŸ‘‰ c EXISTE DÃ‰JÃ€
	â¡ on veut juste REMPLACER son contenu
	â†’ opÃ©rateur dâ€™affectation.

2. Exemple rÃ©el dans un programme

	Dans un vrai code tu fais presque jamais :
	Fixed c(b);

	Tu fais plutÃ´t :
	Fixed c;          // crÃ©Ã© vide au dÃ©but

	// plus tard dans le programme :
	if (condition)
		c = b;
	else
		c = a;
	â¡ lÃ  tu es OBLIGÃ‰ dâ€™avoir un operator=