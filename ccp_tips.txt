////// Classes, Objets, Attributs d'instance ///////

ğŸ’¡ Imaginons la classe Account

	Account a(100);
	Account b(50); 

â€¢	a et b sont deux objets diffÃ©rents
â€¢	Chacun a ses propres donnÃ©es : montant (_amount), nombre de dÃ©pÃ´ts, etc.
â€¢	Ces donnÃ©es sont appelÃ©es attributs dâ€™instance
â¸»

ğŸ“¦ Attribut dâ€™instance ? Câ€™est quoi ?

Un attribut dâ€™instance = une variable qui appartient Ã  un objet prÃ©cis

	class Account {
	private:
	    int _amount; // â† cet attribut appartient Ã  chaque objet Account
	};

â¡ï¸ Chaque objet (a, b, etc.) a sa propre version de _amount
â¸»

âœ… Et maintenant, câ€™est quoi lâ€™objet courant ?

Quand tu es dans une mÃ©thode de la classe, par exemple :

	void Account::makeDeposit(int deposit)

C++ a besoin de savoir :
Â« Je suis en train de faire un dÃ©pÃ´tâ€¦ mais sur quel objet ? Â»

ğŸ‘‰ Câ€™est lâ€™objet courant !
Câ€™est celui qui est en train dâ€™exÃ©cuter la mÃ©thode.

Et pour y accÃ©der, on utilise le mot-clÃ© this :

	this->_amount += deposit;

ğŸ¯ RÃ©sumÃ©

Terme					Explication courte
Objet					Instance concrÃ¨te d'une classe (Account a;)
Attribut d'instance		Variable propre Ã  chaque objet (_amount, _nbDeposits, etc.)
Objet courant			L'objet qui appelle la mÃ©thode (a.makeDeposit())
this					Pointeur vers l'objet courant, utilisÃ© pour accÃ©der Ã  ses donnÃ©es

///////////// MÃ©thodes statiques et mÃ©thodes dâ€™instance //////////////

ğŸŸ© displayAccountsInfos() â†’ fonction static
	â€¢	Elle est marquÃ©e comme statique (dans le header).
	â€¢	Cela veut dire quâ€™elle appartient Ã  la classe, pas Ã  un objet prÃ©cis.
	â€¢	ğŸ‘‰ Elle nâ€™a donc pas accÃ¨s Ã  this, car this reprÃ©sente un objet spÃ©cifique.

Tu ne peux pas utiliser this dans une fonction static, car il nâ€™y a pas dâ€™objet courant.

Câ€™est pour Ã§a quâ€™on utilise directement les variables statiques :
	_nbAccounts, _totalAmount, etc.
â¡ï¸ Elles sont partagÃ©es par toute la classe (communes Ã  tous les objets).
_____
ğŸŸ¦ displayStatus() â†’ fonction dâ€™instance (non static)
	â€¢	Cette mÃ©thode sâ€™applique Ã  un seul objet Ã  la fois
	â€¢	Ici, tu veux afficher les infos de CE compte-lÃ , pas de tous les comptes

this est automatiquement disponible et pointe vers lâ€™objet courant

Donc tu peux faire :
	this->_amount 
ou simplement _amount (le compilateur comprend)

///////// Particularites  /////////
Pourquoi pas empty(str) ou length(str) ?
 -> en C++, les chaÃ®nes sont des objets (std::string).
 Les fonctions associÃ©es Ã  ces objets sâ€™appellent avec la notation point (objet.methode()).

std::isspace(str[i])
 Ici str[i] est un char, pas un objet.
 "char" est un type primitif, il nâ€™a pas de mÃ©thodes associÃ©es.
 Donc on ne peut pas Ã©crire str[i].isspace().
 Ã€ la place, on utilise des fonctions libres (dans <cctype>) qui prennent un char en argument :
 std::isspace(c) â†’ retourne vrai si c est un espace, tabulation, saut de ligne, etc.
 std::isdigit(c) â†’ vrai si c est un chiffre.
 std::isalpha(c)

///////// BASES FONCTIONS /////////

âœ… std :
	â€¢ AbrÃ©viation de Standard
	â€¢ Câ€™est un namespace qui contient toutes les fonctionnalitÃ©s standard de C++
	(fonctions, classes, objets, etc.)
	â€¢ #include <iostream>

âœ… cout
	â€¢ Signifie â€œcharacter outputâ€
	â€¢ Câ€™est un objet (une instance) de la classe std::ostream
	â€¢ Il sert Ã  afficher des choses dans le terminal
	â€¢ Lâ€™Ã©quivalent C de printf, mais version orientÃ©e objet
	â€¢ std::cout << "Hello"; -> Affiche "Hello" dans le terminal, via le flux de sortie standard.

ğŸ” std::endl
âœ… Que signifie endl ?
	â€¢	AbrÃ©viation de â€œend lineâ€ (fin de ligne)
	â€¢	Câ€™est une fonction qui :
		1.	Ajoute un \n (retour Ã  la ligne)
		2.	Flush(=laver, rincer) le buffer de sortie

â“ Flush ?
Quand je fais :
	std::cout << "Texte";
C++ peut mettre le texte de cÃ´tÃ© en mÃ©moire (buffer) avant de vraiment lâ€™Ã©crire dans le terminal.

Mais quand je fais :
	std::cout << std::endl;
â¡ï¸ il force immÃ©diatement lâ€™affichage avec un flush, en plus du saut de ligne.


âœ… cin
	â€¢ Signifie "character input"
	â€¢ Câ€™est un objet de la classe std::istream
	â€¢ Sert Ã  lire des donnÃ©es depuis le clavier (entrÃ©e standard)
	â€¢ Lâ€™Ã©quivalent de scanf en C
	â€¢ Exemple :
		std::string name;
		std::cin >> name; // lit un mot entrÃ© par l'utilisateur

	âš ï¸ std::cin lit jusquâ€™Ã  un espace ou un saut de ligne

âœ… std::cin.clear()
	â€¢ Fonction membre de `std::istream` (donc utilisÃ©e avec `std::cin`)
	â€¢ Sert Ã  **rÃ©initialiser les flags dâ€™erreur** du flux dâ€™entrÃ©e
	â€¢ TrÃ¨s souvent utilisÃ©e aprÃ¨s une **entrÃ©e invalide**
	â€¢ Par dÃ©faut, une erreur (ex : lire du texte alors qu'on attendait un int) met le flux en Ã©tat "dâ€™Ã©chec" (failbit)
	â€¢ Tant que ce flag nâ€™est pas effacÃ© avec `.clear()`, le flux refuse de lire de nouvelles donnÃ©es
	â€¢ NÃ©cessite : `#include <iostream>`

âœ… std::getline(...)
	â€¢ ex : std::getline(std::cin, command);
	â€¢ Fonction qui lit une ligne entiÃ¨re depuis un flux (std::cin) et la stocke dans une chaÃ®ne (command).
	â€¢ Contrairement Ã  std::cin >> command; qui sâ€™arrÃªte au premier espace,
	  std::getline prend tout ce que tu as Ã©crit jusquâ€™au retour Ã  la ligne (Enter).

/////// ADVANCED TIPS ////////

âœ… std::cin.ignore(n, c)
	â€¢ Ignore jusquâ€™Ã  n caractÃ¨res dans le flux ou jusquâ€™Ã  rencontrer le caractÃ¨re c (inclus).
	â€¢ Souvent, c est '\n', donc on ignore tout jusquâ€™Ã  la fin de la ligne en cours.

âœ…std::numeric_limits<std::streamsize>::max()

	â€¢ std::numeric_limits : template qui permet dâ€™obtenir les limites des types numÃ©riques.
	â€¢ std::streamsize : type signÃ© utilisÃ© pour reprÃ©senter la taille dâ€™un flux.

	â†’ std::numeric_limits<std::streamsize>::max() retourne la valeur maximale
		possible pour un std::streamsize (câ€™est Ã©norme, genre 9.22e18 sur 64 bits)

-----------------------
DONC POUR : std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n')

==> On dit Ã  ignore :
Â« Ignore autant de caractÃ¨res que possible, mais arrÃªte-toi dÃ¨s que tu croises un '\n'. Â»
-----------------------

âœ… cerr
	â€¢ Signifie "character error"
	â€¢ Câ€™est un objet de la classe std::ostream (comme cout)
	â€¢ Sert Ã  afficher des messages dâ€™erreur
	â€¢ Sâ€™affiche aussi dans le terminal, mais sur le **flux dâ€™erreur** (stderr)
	â€¢ Utile pour sÃ©parer les erreurs de la sortie standard
	â€¢ Exemple :
		std::cerr << "Erreur : fichier introuvable" << std::endl;

âœ… stringstream (nÃ©cessite #include <sstream>)
	â€¢ Câ€™est une classe qui permet dâ€™utiliser une string comme un flux (comme cin/cout)
	â€¢ TrÃ¨s utile pour convertir entre types, ou parser des strings
	â€¢ Il existe trois variantes :
		- std::stringstream (lecture + Ã©criture)
		- std::istringstream (lecture uniquement)
		- std::ostringstream (Ã©criture uniquement)

	â€¢ Exemple simple dâ€™extraction :
		#include <sstream>
		std::string line = "42 hello";
		std::stringstream ss(line);
		int number;
		std::string word;
		ss >> number >> word;
		// number = 42, word = "hello"

	â€¢ Exemple pour convertir int â†’ string :
		std::ostringstream oss;
		oss << 123;
		std::string s = oss.str(); // "123"

	â€¢ Exemple pour convertir string â†’ int :
		std::istringstream iss("456");
		int x;
		iss >> x; // x = 456